<?xml version="1.0"?>
<root main_tree_to_execute="MainTree">
    <!-- ////////// -->
    <BehaviorTree ID="MainTree">
        <Control ID="RecoveryNode" number_of_retries="10">
            <Sequence>
                <Action ID="ClearEntireCostmap" name="ClearLocalCostmap-Context" service_name="local_costmap/clear_entirely_local_costmap"/>
                <Control ID="PipelineSequence" name="NavigateWithReplanning">
                    <Decorator ID="RateController" hz="1.0">
                        <Action ID="ComputePathToPose" goal="{goal}" path="{path}" planner_id="TopicBased"/>
                    </Decorator>
                    <Decorator ID="RateController" hz="1.0" name="RateControllerObstacle">
                        <Fallback>
                            <Action ID="CheckFrontObstacle" angle="0.2" range="1.5" rotate_threshold="0.15"/>
                            <Action ID="CheckRobotOrientation" distance_forward="2.0" distance_threshold="1.5" path="{path}" threshold="0.25"/>
                        </Fallback>
                    </Decorator>
                    <Action ID="FollowPath" controller_id="FollowPath" goal_checker_id="general_goal_checker" path="{path}"/>
                </Control>
            </Sequence>
            <SubTree ID="NavigateToLppPose" __shared_blackboard="true"/>
        </Control>
    </BehaviorTree>
    <!-- ////////// -->
    <BehaviorTree ID="NavigateToLppPose">
        <Fallback>
            <Sequence name="SequenceBeforeLpp">
                <Action ID="Wait" name="WaitBeforeLpp" wait_duration="5"/>
                <Fallback name="FallbackBeforeLpp">
                    <Condition ID="GoalUpdated" name="GoalUpdatedBeforeLpp"/>
                    <Action ID="CheckFrontObstacle" angle="0.66" name="CheckFrontObstacleBeforeLpp" range="1.5" rotate_threshold="0.15"/>
                </Fallback>
            </Sequence>
            <Inverter>
                <Action ID="RequestTriggerLpp" lpp_duration="{lpp_duration}"/>
            </Inverter>
            <RetryUntilSuccessful num_attempts="100">
                <Sequence>
                    <Action ID="SetLppGoal" lpp_duration="{lpp_duration}" lpp_goal="{lpp_goal}" path="{path}"/>
                    <ReactiveFallback>
                        <Condition ID="GoalUpdated" name="GoalUpdatedWhileLpp"/>
                        <Timeout msec="{lpp_duration}" name="FollowLPPTimeout">
                            <Control ID="PipelineSequence">
                                <Decorator ID="RateController" hz="1.0" name="RateControllerComputeLppPath">
                                    <Action ID="ComputePathToPose" goal="{lpp_goal}" name="ComputePathToLppGoal" path="{lpp_path}" planner_id="GridBased"/>
                                </Decorator>
                                <Control ID="RecoveryNode" number_of_retries="4">
                                    <Action ID="FollowPath" controller_id="FollowPath" goal_checker_id="only_position_checker" name="FollowLppPath" path="{lpp_path}"/>
                                    <Action ID="Spin" spin_dist="1.57"/>
                                </Control>
                            </Control>
                        </Timeout>
                        <Action ID="CheckFrontObstacle" angle="0.66" name="CheckFrontObstacleAfterLpp" range="1.5" rotate_threshold="0.15"/>
                    </ReactiveFallback>
                    <Action ID="SendLppEnd"/>
                </Sequence>
            </RetryUntilSuccessful>
        </Fallback>
    </BehaviorTree>
    <!-- ////////// -->
    <TreeNodesModel>
        <Condition ID="AreErrorCodesPresent">
            <input_port name="error_code">Error code</input_port>
            <input_port name="error_codes_to_check">Error codes to check, user defined</input_port>
        </Condition>
        <Action ID="AssistedTeleop">
            <input_port name="is_recovery">If true recovery count will be incremented</input_port>
            <input_port name="server_name">Service name</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="time_allowance">Allowed time for spinning</input_port>
        </Action>
        <Action ID="BackUp">
            <input_port name="backup_dist">Distance to backup</input_port>
            <input_port name="backup_speed">Speed at which to backup</input_port>
            <input_port name="server_name">Server name</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="time_allowance">Allowed time for reversing</input_port>
        </Action>
        <Action ID="CancelAssistedTeleop">
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="service_name">Service name to cancel the assisted teleop behavior</input_port>
        </Action>
        <Action ID="CancelBackUp">
            <input_port name="server_name">Server name to cancel the backup behavior</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <Action ID="CancelControl">
            <input_port name="server_name">Server name to cancel the controller server</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <Action ID="CancelDriveOnHeading">
            <input_port name="server_name">Service name to cancel the drive on heading behavior</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <Action ID="CancelSpin">
            <input_port name="server_name">Server name to cancel the spin behavior</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <Action ID="CancelWait">
            <input_port name="server_name">Server name to cancel the wait behavior</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <Action ID="CheckFrontObstacle">
            <input_port default="0.4" name="angle"/>
            <input_port default="2.1" name="range"/>
            <input_port default="0.5" name="rotate_threshold"/>
        </Action>
        <Action ID="CheckRobotOrientation">
            <input_port default="2.0" name="distance_forward"/>
            <input_port default="1.5" name="distance_threshold"/>
            <input_port default="{path}" name="path"/>
            <input_port default="1.0" name="threshold"/>
        </Action>
        <Action ID="ClearCostmapAroundRobot">
            <input_port name="reset_distance">Distance from the robot under which obstacles are cleared</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="service_name">Service name</input_port>
        </Action>
        <Action ID="ClearCostmapExceptRegion">
            <input_port name="reset_distance">Distance from the robot above which obstacles are cleared</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="service_name">Service name</input_port>
        </Action>
        <Action ID="ClearEntireCostmap">
            <input_port name="service_name">Service name</input_port>
        </Action>
        <Action ID="ComputePathThroughPoses">
            <input_port name="goals">Destinations to plan through</input_port>
            <output_port name="path">Path created by ComputePathToPose node</output_port>
            <input_port name="planner_id">Mapped name to the planner plugin type to use</input_port>
        </Action>
        <Action ID="ComputePathToPose">
            <input_port name="goal">Destination to plan to</input_port>
            <output_port name="path">Path created by ComputePathToPose node</output_port>
            <input_port name="planner_id">Mapped name to the planner plugin type to use</input_port>
        </Action>
        <Action ID="ControllerSelector">
            <input_port name="default_controller">Default controller of the controller selector</input_port>
            <output_port name="selected_controller">Name of the selected controller received from the topic subcription</output_port>
            <input_port name="topic_name">Name of the topic to receive controller selection commands</input_port>
        </Action>
        <Decorator ID="DistanceController">
            <input_port name="distance">Distance</input_port>
            <input_port name="global_frame">Reference frame</input_port>
            <input_port name="robot_base_frame">Robot base frame</input_port>
        </Decorator>
        <Condition ID="DistanceTraveled">
            <input_port name="distance">Distance to check if passed</input_port>
            <input_port name="global_frame">reference frame to check in</input_port>
            <input_port name="robot_base_frame">Robot frame to check relative to global_frame</input_port>
        </Condition>
        <Action ID="DriveOnHeading">
            <input_port name="dist_to_travel">Distance to travel</input_port>
            <input_port name="server_name">Server name</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="speed">Speed at which to travel</input_port>
            <input_port name="time_allowance">Allowed time for reversing</input_port>
        </Action>
        <Action ID="FollowPath">
            <input_port default="FollowPath" name="controller_id"/>
            <input_port default="GoalChecker" name="goal_checker_id">Goal checker</input_port>
            <input_port name="path">Path to follow</input_port>
        </Action>
        <Condition ID="GlobalUpdatedGoal"/>
        <Action ID="GoalCheckerSelector">
            <input_port name="default_goal_checker">Default goal checker of the controller selector</input_port>
            <output_port name="selected_goal_checker">Name of the selected goal checker received from the topic subcription</output_port>
            <input_port name="topic_name">Name of the topic to receive goal checker selection commands</input_port>
        </Action>
        <Condition ID="GoalReached">
            <input_port name="global_frame">Reference frame</input_port>
            <input_port name="goal">Destination</input_port>
            <input_port name="robot_base_frame">Robot base frame</input_port>
        </Condition>
        <Condition ID="GoalUpdated"/>
        <Decorator ID="GoalUpdatedController"/>
        <Decorator ID="GoalUpdater">
            <input_port name="input_goal">Original goal in</input_port>
            <output_port name="output_goal">Output goal set by subscription</output_port>
        </Decorator>
        <Condition ID="InitialPoseReceived"/>
        <Condition ID="IsBatteryLow">
            <input_port name="battery_topic">Topic for battery info</input_port>
            <input_port name="is_voltage">Bool if check based on voltage or total %</input_port>
            <input_port name="min_battery">Min battery % or voltage before triggering</input_port>
        </Condition>
        <Condition ID="IsPathValid">
            <input_port name="path"> Path to validate </input_port>
            <input_port name="server_timeout"> Server timeout </input_port>
        </Condition>
        <Condition ID="IsStuck"/>
        <Action ID="NavigateThroughPoses">
            <input_port name="behavior_tree">Behavior tree to run</input_port>
            <input_port name="goals">Goals</input_port>
            <input_port name="server_name">Server name</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <SubTree ID="NavigateToLppPose">
            <input_port default="true" name="__shared_blackboard">If false (default), the Subtree has an isolated blackboard and needs port remapping</input_port>
        </SubTree>
        <Action ID="NavigateToPose">
            <input_port name="behavior_tree">Behavior tree to run</input_port>
            <input_port name="goal">Goal</input_port>
            <input_port name="server_name">Server name</input_port>
            <input_port name="server_timeout">Server timeout</input_port>
        </Action>
        <Condition ID="PathExpiringTimer">
            <input_port name="path">Check if path has been updated to enable timer reset</input_port>
            <input_port name="seconds">Time to check if expired</input_port>
        </Condition>
        <Decorator ID="PathLongerOnApproach">
            <input_port name="length_factor">Length multiplication factor to check if the path is significantly longer </input_port>
            <input_port name="path">Planned Path</input_port>
            <input_port name="prox_len">Proximity length (m) for the path to be longer on approach</input_port>
        </Decorator>
        <Control ID="PipelineSequence"/>
        <Action ID="PlannerSelector">
            <input_port name="default_planner">Default planner of the planner selector</input_port>
            <output_port name="selected_planner">Name of the selected planner received from the topic subcription</output_port>
            <input_port name="topic_name">Name of the topic to receive planner selection commands</input_port>
        </Action>
        <Decorator ID="RateController">
            <input_port name="hz">Rate</input_port>
        </Decorator>
        <Control ID="RecoveryNode">
            <input_port name="number_of_retries">Number of retries</input_port>
        </Control>
        <Action ID="ReinitializeGlobalLocalization">
            <input_port name="server_timeout">Server timeout</input_port>
            <input_port name="service_name">Service name</input_port>
        </Action>
        <Action ID="RemovePassedGoals">
            <input_port name="global_frame">Global frame</input_port>
            <input_port name="input_goals">Input goals to remove if passed</input_port>
            <output_port name="output_goals">Set of goals after removing any passed</output_port>
            <input_port name="radius">Radius tolerance on a goal to consider it passed</input_port>
            <input_port name="robot_base_frame">Robot base frame</input_port>
        </Action>
        <Action ID="RequestTriggerLpp">
            <output_port default="{lpp_duration}" name="lpp_duration"/>
        </Action>
        <Control ID="RoundRobin"/>
        <Action ID="SendLppEnd"/>
        <Action ID="SetLppGoal">
            <input_port default="{lpp_duration}" name="lpp_duration"/>
            <output_port default="{lpp_goal}" name="lpp_goal"/>
            <input_port default="{path}" name="path"/>
        </Action>
        <Decorator ID="SingleTrigger"/>
        <Action ID="SmoothPath">
            <input_port name="check_for_collisions">Bool if collision check should be performed</input_port>
            <input_port name="max_smoothing_duration">Maximum smoothing duration</input_port>
            <output_port name="smoothed_path">Smoothed path</output_port>
            <input_port default="SmoothPath" name="smoother_id"/>
            <output_port name="smoothing_duration">Smoothing duration</output_port>
            <input_port name="unsmoothed_path">Path to be smoothed</input_port>
            <output_port name="was_completed">True if smoothing was not interrupted by time limit</output_port>
        </Action>
        <Action ID="SmootherSelector">
            <input_port name="default_smoother">Default smoother of the smoother selector</input_port>
            <output_port name="selected_smoother">Name of the selected smoother received from the topic subcription</output_port>
            <input_port name="topic_name">Name of the topic to receive smoother selection commands</input_port>
        </Action>
        <Decorator ID="SpeedController">
            <input_port name="max_rate">Maximum rate</input_port>
            <input_port name="max_speed">Maximum speed</input_port>
            <input_port name="min_rate">Minimum rate</input_port>
            <input_port name="min_speed">Minimum speed</input_port>
        </Decorator>
        <Action ID="Spin">
            <input_port name="spin_dist">Spin distance</input_port>
        </Action>
        <Condition ID="TimeExpired">
            <input_port name="seconds">Time to check if expired</input_port>
        </Condition>
        <Condition ID="TransformAvailable">
            <input_port name="child">Child frame for transform</input_port>
            <input_port name="parent">Parent frame for transform</input_port>
        </Condition>
        <Action ID="TruncatePath">
            <input_port name="distance">Distance before goal to truncate</input_port>
            <input_port name="input_path">Path to truncate</input_port>
            <output_port name="output_path">Truncated path to utilize</output_port>
        </Action>
        <Action ID="TruncatePathLocal">
            <input_port name="angular_distance_weight">Weight of angular distance relative to positional distance when finding which path pose is closest to robot. Not applicable on paths without orientations assigned</input_port>
            <input_port name="distance_backward">Distance in backward direction</input_port>
            <input_port name="distance_forward">Distance in forward direction</input_port>
            <input_port name="input_path"/>
            <output_port name="output_path">Truncated path to utilize</output_port>
        </Action>
        <Action ID="Wait">
            <input_port name="wait_duration">Wait time</input_port>
        </Action>
        <Condition ID="WouldAControllerRecoveryHelp">
            <input_port name="error_code">Error code</input_port>
        </Condition>
        <Condition ID="WouldAPlannerRecoveryHelp">
            <input_port name="error_code">Error code</input_port>
        </Condition>
        <Condition ID="WouldASmootherRecoveryHelp">
            <input_port name="error_code">Error code</input_port>
        </Condition>
    </TreeNodesModel>
    <!-- ////////// -->
</root>
